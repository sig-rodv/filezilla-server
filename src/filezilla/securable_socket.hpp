#ifndef SECURABLE_CHANNEL_HPP
#define SECURABLE_CHANNEL_HPP

#include <variant>
#include <optional>

#include <libfilezilla/socket.hpp>
#include <libfilezilla/tls_layer.hpp>
#include <libfilezilla/tls_info.hpp>
#include <libfilezilla/tls_system_trust_store.hpp>
#include <libfilezilla/uri.hpp>

#include "../filezilla/socket_stack.hpp"
#include "../filezilla/util/filesystem.hpp"
#include "../filezilla/acme/cert_info.hpp"

namespace fz {

enum class securable_socket_state {
	wrong_alpn = -5,
	invalid_socket_state = -4,
	failed_setting_certificate_file = -3,
	session_socket_not_secure = -2,
	session_not_resumed = -1,
	insecure,
	about_to_secure,
	securing,
	secured
};

class securable_socket: public socket_stack_interface
{
public:
	struct user_provided_cert_info
	{
		native_string key_path;
		native_string certs_path;
		native_string password;

		struct extra
		{
			std::string fingerprint{};
			std::string distinguished_name{};
			std::vector<std::string> hostnames{};
			fz::datetime activation_time{};
			fz::datetime expiration_time{};
		};
	};

	struct autogenerated_cert_info
	{
		std::string fingerprint;

		struct extra
		{
			std::string distinguished_name{};
			std::vector<std::string> hostnames{};
			fz::datetime activation_time{};
			fz::datetime expiration_time{};
		};
	};

	struct uploaded_cert_info
	{
		native_string key_path;
		native_string certs_path;
		native_string password;

		struct extra
		{
			std::string fingerprint{};
			std::string distinguished_name{};
			std::vector<std::string> hostnames{};
			fz::datetime activation_time{};
			fz::datetime expiration_time{};
		};
	};

	using acme_cert_info = fz::acme::cert_info;

	struct exported_cert_info
	{
		std::variant<
			std::monostate,
			user_provided_cert_info,
			autogenerated_cert_info,
			acme_cert_info,
			uploaded_cert_info
		> original;

		std::string certs;
		std::string key; ///< If empty, then the key is contained within certs.

		user_provided_cert_info *user_provided() { return std::get_if<user_provided_cert_info>(&original); }
		autogenerated_cert_info *autogenerated() { return std::get_if<autogenerated_cert_info>(&original); }
		acme_cert_info *acme() { return std::get_if<acme_cert_info>(&original); }
		uploaded_cert_info *uploaded() { return std::get_if<uploaded_cert_info>(&original); }

		const user_provided_cert_info *user_provided() const { return std::get_if<user_provided_cert_info>(&original); }
		const autogenerated_cert_info *autogenerated() const { return std::get_if<autogenerated_cert_info>(&original); }
		const acme_cert_info *acme() const { return std::get_if<acme_cert_info>(&original); }
		const uploaded_cert_info *uploaded() const { return std::get_if<uploaded_cert_info>(&original); }
	};

	// If cert_info holds a exported_cert_info type, when set_root_path is invoked
	// Then cert_info is transformed into holding another, best fitting, type,
	// and the certs and key are written to the proper files.
	struct cert_info: std::variant<
		std::monostate,
		user_provided_cert_info,
		autogenerated_cert_info,
		acme_cert_info,
		exported_cert_info,
		uploaded_cert_info
	>
	{
		struct extra: std::variant<
			std::monostate,
			user_provided_cert_info::extra,
			autogenerated_cert_info::extra,
			acme_cert_info::extra,
			uploaded_cert_info::extra
		>{
			using variant::variant;

			bool has_value() const
			{
				return !std::holds_alternative<std::monostate>(*this);
			}

			explicit operator bool() const
			{
				return has_value();
			}

			bool expired() const;

			user_provided_cert_info::extra *user_provided() { return std::get_if<user_provided_cert_info::extra>(this); }
			autogenerated_cert_info::extra *autogenerated() { return std::get_if<autogenerated_cert_info::extra>(this); }
			acme_cert_info::extra *acme() { return std::get_if<acme_cert_info::extra>(this); }
			uploaded_cert_info::extra *uploaded() { return std::get_if<uploaded_cert_info::extra>(this); }

			const user_provided_cert_info::extra *user_provided() const { return std::get_if<user_provided_cert_info::extra>(this); }
			const autogenerated_cert_info::extra *autogenerated() const { return std::get_if<autogenerated_cert_info::extra>(this); }
			const acme_cert_info::extra *acme() const { return std::get_if<acme_cert_info::extra>(this); }
			const uploaded_cert_info::extra *uploaded() const { return std::get_if<uploaded_cert_info::extra>(this); }
		};

		template <typename... Args, std::enable_if_t<std::is_constructible_v<variant, Args...>>* = nullptr>
		cert_info(Args &&... args)
			: variant(std::forward<Args>(args)...)
		{
			resolve_paths();
		}

		template <typename... Args, std::enable_if_t<std::is_invocable_v<variant, Args...>>* = nullptr>
		cert_info &operator=(Args &&... args)
		{
			variant::operator=(std::forward<Args>(args)...);
			resolve_paths();
			return *this;
		}

		cert_info(const cert_info &) = default;
		cert_info(cert_info &&) = default;
		cert_info &operator=(const cert_info &) = default;
		cert_info &operator=(cert_info &&) = default;

		bool is_valid() const
		{
			return std::get_if<std::monostate>(this) == nullptr;
		}

		explicit operator bool() const
		{
			return is_valid();
		}

		bool set_root_path(const util::fs::native_path &root_path, logger_interface *logger = nullptr);

		const util::fs::native_path &key_path() const;
		const util::fs::native_path &certs_path() const;

		native_string password() const;

		std::vector<x509_certificate> load_certs(fz::logger_interface *logger = nullptr) const;
		extra load_extra(fz::logger_interface *logger = nullptr) const;

		void dump(logger_interface &logger, bool only_sha256);
		static cert_info generate_selfsigned(const util::fs::native_path &root_path, logger_interface *logger = {}, native_string const& password = {}, std::string const& distinguished_name = {}, std::vector<std::string> const& hostnames = {});
		static cert_info import_certificate_files(const util::fs::native_path &root_path, const std::string &cert, const std::string &key, const native_string &password, logger_interface *logger = {});

		cert_info generate_exported() const;

		void remove();

		user_provided_cert_info *user_provided() { return std::get_if<user_provided_cert_info>(this); }
		autogenerated_cert_info *autogenerated() { return std::get_if<autogenerated_cert_info>(this); }
		acme_cert_info *acme() { return std::get_if<acme_cert_info>(this); }
		uploaded_cert_info *uploaded() { return std::get_if<uploaded_cert_info>(this); }

		const user_provided_cert_info *user_provided() const { return std::get_if<user_provided_cert_info>(this); }
		const autogenerated_cert_info *autogenerated() const { return std::get_if<autogenerated_cert_info>(this); }
		const acme_cert_info *acme() const { return std::get_if<acme_cert_info>(this); }
		const uploaded_cert_info *uploaded() const { return std::get_if<uploaded_cert_info>(this); }

		std::string fingerprint(const extra &extra) const;

	private:
		bool resolve_paths(fz::logger_interface *logger = nullptr);

		util::fs::native_path root_path_;
		util::fs::native_path resolved_key_path_;
		util::fs::native_path resolved_certs_path_;
	};

	struct info
	{
		cert_info cert;
		tls_ver min_tls_ver = tls_ver::v1_2;
	};

	struct session_info {
		using algorithm_warnings_t = tls_session_info::algorithm_warnings_t;

		/// The symmetric algorithm used to encrypt all exchanged application data
		std::string cipher;

		/// The MAC used for integrity-protect and authenticate the exchanged application data
		std::string mac;

		/// TLS version
		std::string tls_version;

		/// Key exchange algorithm
		std::string key_exchange;

		/// Warnings about old algorithms used, which are considered weak
		algorithm_warnings_t algorithm_warnings;
	};

	struct securer {
		~securer();

		securer(const securer &) = delete;
		securer(securer &&) = delete;
		securer &operator=(const securer &) = delete;
		securer &operator=(securer &&) = delete;

		operator bool() const
		{
			return owner_.securable_state_ >= securable_socket_state::about_to_secure;
		}

		securable_socket_state get_state() const
		{
			return owner_.securable_state_;
		}

	private:
		friend securable_socket;

		securer(securable_socket &owner,
				bool make_server,
				tls_ver min_tls_ver,
				const securable_socket::cert_info *cert_info,
				tls_system_trust_store *trust_store,
				securable_socket *socket_to_get_tls_session_from,
				std::string_view preamble,
				std::vector<std::string> alpns,
				bool alpn_mandatory);

		securable_socket &owner_;
		bool make_server_{};
		securable_socket *socket_to_get_tls_session_from_{};
		std::string preamble_{};
		std::vector<std::string> alpns_{};
		bool alpn_mandatory_;
	};

	securable_socket(event_loop &loop, event_handler *event_handler, std::unique_ptr<socket> socket_, logger_interface &logger);
	securable_socket(event_loop &loop, event_handler *event_handler, std::unique_ptr<socket_stack> socket_stack, logger_interface &logger);
	~securable_socket() override;

	securer make_secure_server(tls_ver min_tls_ver, const cert_info &cert_info, securable_socket *socket_to_get_tls_session_from = {}, std::string_view preamble = {}, std::vector<std::string> alpns = {}, bool alpn_mandatory = false);
	securer make_secure_client(tls_ver min_tls_ver, const cert_info *cert_info = {}, tls_system_trust_store *trust_store = {}, securable_socket *socket_to_get_tls_session_from = {}, std::vector<std::string> alpns = {}, bool alpn_mandatory = false);

	securable_socket_state get_securable_state() const;
	bool is_secure() const
	{
		return get_securable_state() == securable_socket_state::secured;
	}

	std::optional<session_info> get_session_info() const;

	void set_verification_result(bool trusted);

	int new_session_ticket();

	std::string get_alpn() const;

	void set_unexpected_eof_cb(std::function<bool()> cb);

	// socket_stack_interface interface
public:
	void push(std::unique_ptr<socket_layer> socket_layer) override
	{
		socket_stack_->push(std::move(socket_layer));
	}

	void pop() override
	{
		socket_stack_->pop();
	}

	socket_interface &top() const override
	{
		return socket_stack_->top();
	}

	address_type address_family() const override
	{
		return socket_stack_->address_family();
	}

	std::string local_ip(bool strip_zone_index = false) const override
	{
		return socket_stack_->local_ip(strip_zone_index);
	}

	int local_port(int &error) const override
	{
		return socket_stack_->local_port(error);
	}

	std::string peer_ip() const override {
		return socket_stack_->peer_ip();
	}

	int flags() const override
	{
		return socket_stack_->flags();
	}

	void set_flags(int flags, bool enable) override
	{
		socket_stack_->set_flags(flags, enable);
	}

	void set_flags(int flags) override
	{
		socket_stack_->set_flags(flags);
	}

	void set_keepalive_interval(duration const& d) override
	{
		socket_stack_->set_keepalive_interval(d);
	}

	int set_buffer_sizes(int size_receive, int size_send) override
	{
		return socket_stack_->set_buffer_sizes(size_receive, size_send);
	}

	// socket_interface interface
public:
	int read(void *buffer, unsigned int size, int &error) override {
		return socket_stack_->read(buffer, size, error);
	}

	int write(const void *buffer, unsigned int size, int &error) override {
		return socket_stack_->write(buffer, size, error);
	}

	void set_event_handler(event_handler *pEvtHandler, fz::socket_event_flag retrigger_block = {}) override {
		event_handler_ = pEvtHandler;
		return socket_stack_->set_event_handler(pEvtHandler, retrigger_block);
	}

	native_string peer_host() const override {
		return socket_stack_->peer_host();
	}

	int peer_port(int &error) const override {
		return socket_stack_->peer_port(error);
	}

	int connect(const native_string &host, unsigned int port, address_type family = address_type::unknown) override {
		return socket_stack_->connect(host, port, family);
	}

	socket_state get_state() const override {
		return socket_stack_->get_state();
	}

	int shutdown() override;

	int shutdown_read() override;

private:
	event_loop &event_loop_;
	event_handler *event_handler_{};
	logger_interface &logger_;

	std::unique_ptr<socket_stack> socket_stack_{};
	tls_layer *tls_layer_{};
	securable_socket_state securable_state_{securable_socket_state::insecure};

	std::function<bool()> eof_cb_;
};

}
#endif // SECURABLE_CHANNEL_HPP
