#include <typeinfo>

#include <libfilezilla/logger.hpp>
#include <libfilezilla/tls_info.hpp>
#include <libfilezilla/recursive_remove.hpp>
#include <libfilezilla/hash.hpp>
#include <libfilezilla/util.hpp>

#include "util/filesystem.hpp"
#include "util/io.hpp"

#include "util/overload.hpp"

#include "securable_socket.hpp"

namespace fz {

securable_socket::securable_socket(event_loop &loop,  event_handler *event_handler, std::unique_ptr<socket> socket, logger_interface &logger)
	: socket_stack_interface(socket->root())
	, event_loop_(loop)
	, event_handler_(event_handler)
	, logger_(logger)
	, socket_stack_(new socket_stack(std::move(socket)))
{
}

securable_socket::securable_socket(event_loop &loop, event_handler *event_handler, std::unique_ptr<socket_stack> socket_stack, logger_interface &logger)
	: socket_stack_interface(socket_stack->root())
	, event_loop_(loop)
	, event_handler_(event_handler)
	, logger_(logger)
	, socket_stack_(std::move(socket_stack))
{
}

securable_socket::~securable_socket()
{
}

securable_socket_state securable_socket::get_securable_state() const
{
	if (tls_layer_) {
		auto s = tls_layer_->get_state();

		if (s == socket_state::connected)
			return securable_socket_state::secured;

		if (s != socket_state::none && s != socket_state::connecting)
			return securable_socket_state::invalid_socket_state;
	}

	return securable_state_;
}

std::optional<securable_socket::session_info> securable_socket::get_session_info() const
{
	if (!is_secure())
		return {};

	return securable_socket::session_info{
		tls_layer_->get_cipher(),
		tls_layer_->get_mac(),
		tls_layer_->get_protocol(),
		tls_layer_->get_key_exchange(),
		static_cast<tls_session_info::algorithm_warnings_t>(tls_layer_->get_algorithm_warnings())
	};
}

void securable_socket::set_verification_result(bool trusted)
{
	if (tls_layer_)
		tls_layer_->set_verification_result(trusted);
}

int securable_socket::shutdown()
{
	return socket_stack_->shutdown();
}

int securable_socket::shutdown_read()
{
	return socket_stack_->shutdown_read();
}

bool securable_socket::cert_info::set_root_path(const util::fs::native_path &root_path, logger_interface *logger)
{
	if (!root_path.is_absolute()) {
		if (logger)
			logger->log_u(logmsg::error, L"set_root_path: path \"%s\" is not absolute.", root_path);
		return false;
	}

	root_path_ = root_path;
	return resolve_paths(logger);
}

const util::fs::native_path &securable_socket::cert_info::key_path() const
{
	return resolved_key_path_;
}

const util::fs::native_path &securable_socket::cert_info::certs_path() const
{
	return resolved_certs_path_;
}

fz::native_string securable_socket::cert_info::password() const
{
	if (auto d = std::get_if<user_provided_cert_info>(this))
		return d->password;
	else
	if (auto d = std::get_if<uploaded_cert_info>(this))
		return d->password;

	return {};
}

std::vector<x509_certificate> securable_socket::cert_info::load_certs(logger_interface *logger) const
{
	if (!*this)
		return {};

	return fz::load_certificates_file(certs_path(), true, true, logger);
}


securable_socket::cert_info::extra securable_socket::cert_info::load_extra(fz::logger_interface *logger) const
{
	static auto get_hostnames = [](const auto &alt_subjects) {
		std::vector<std::string> hostnames;
		hostnames.reserve(alt_subjects.size());

		for (const auto &s: alt_subjects)
			if (s.is_dns)
				hostnames.push_back(s.name);

		return hostnames;
	};

	if (!std::get_if<exported_cert_info>(this)) {
		if (auto && certs = load_certs(logger); !certs.empty()) {
			auto activation_time = certs[0].get_activation_time();
			auto expiration_time = certs[0].get_expiration_time();

			if (std::get_if<user_provided_cert_info>(this))
				return user_provided_cert_info::extra{ certs[0].get_fingerprint_sha256(), certs[0].get_subject(), get_hostnames(certs[0].get_alt_subject_names()), activation_time, expiration_time };
			else
			if (std::get_if<uploaded_cert_info>(this))
				return uploaded_cert_info::extra{ certs[0].get_fingerprint_sha256(), certs[0].get_subject(), get_hostnames(certs[0].get_alt_subject_names()), activation_time, expiration_time };
			else
			if (std::get_if<autogenerated_cert_info>(this))
				return autogenerated_cert_info::extra{ certs[0].get_subject(), get_hostnames(certs[0].get_alt_subject_names()), activation_time, expiration_time };
			else
			if (auto *ci = std::get_if<acme_cert_info>(this))
				return acme_cert_info::extra{ certs[0].get_fingerprint_sha256(), certs[0].get_subject(), acme::extra_account_info::load(root_path_, ci->account_id), activation_time, expiration_time };
		}
	}

	return {};
}

void securable_socket::cert_info::dump(logger_interface &logger, bool only_sha256)
{
	if (auto && certs = load_certs(&logger); !certs.empty()) {
		if (!only_sha256)
			logger.log_u(fz::logmsg::status, L"SHA1 certificate fingerprint: %s", certs[0].get_fingerprint_sha1());
		logger.log_u(fz::logmsg::status, L"SHA256 certificate fingerprint: %s", certs[0].get_fingerprint_sha256());

		return;
	}

	logger.log_u(fz::logmsg::status, L"No available certificate.");
}

securable_socket::cert_info securable_socket::cert_info::generate_selfsigned(const util::fs::native_path &root_path, logger_interface *logger, native_string const& password, std::string const& distinguished_name, std::vector<std::string> const& hostnames)
{
	auto error = [logger](auto &&... args) {
		if (logger)
			logger->log_u(logmsg::error, std::forward<decltype(args)>(args)...);
	};

	auto status = [logger](auto &&... args) {
		if (logger)
			logger->log_u(logmsg::status, std::forward<decltype(args)>(args)...);
	};

	auto write_to_file = [&error](const util::fs::native_path &path, const std::string &data) -> bool {
		auto out = path.open(file::writing, fz::file::creation_flags::empty | fz::file::creation_flags::current_user_and_admins_only);

		if (!out) {
			error(L"Couldn't open file [%s] for writing.", path);
			return false;
		}

		if (!util::io::write(out, data.data(), data.size())) {
			error(L"Error writing to file [%s].", path);

			return false;
		}

		return true;
	};

	status(L"Generating self-signed certificate.");

	auto [key, cert] = tls_layer::generate_selfsigned_certificate(password, distinguished_name.empty() ? "CN=filezilla-server self signed certificate" : distinguished_name, hostnames);

	cert_info info;

	auto success = !key.empty() && !cert.empty();

	if (success) {
		info = autogenerated_cert_info{ std::move(load_certificates(cert, true, true, logger)[0].get_fingerprint_sha256()) };
		info.set_root_path(root_path);

		success = write_to_file(info.key_path(), key) && write_to_file(info.certs_path(), cert);

		if (!success) {
			info.remove();
			info = {};
		}
	}

	if (!success)
		error(L"Failed generating self-signed certificate.");

	return info;
}

securable_socket::cert_info securable_socket::cert_info::import_certificate_files(const util::fs::native_path &root_path, const std::string &cert, const std::string &key, const native_string &password, logger_interface *logger)
{
	auto error = [logger](auto &&... args) {
		if (logger)
			logger->log_u(logmsg::error, std::forward<decltype(args)>(args)...);
	};

	cert_info info = exported_cert_info {
		uploaded_cert_info {
			{}, {}, password
		},

		cert,
		key
	};

	if (!info.set_root_path(root_path, logger))
		error(L"Failed uploading certificate.");

	return info;
}

securable_socket::cert_info securable_socket::cert_info::generate_exported() const
{
	if (root_path_.str().empty())
		return {};

	exported_cert_info exported;

	exported.certs = fz::util::io::read(certs_path()).to_view();
	if (exported.certs.empty())
		return {};

	if (key_path() != certs_path() && (exported.key = fz::util::io::read(key_path()).to_view()).empty())
		return {};

	if (exported.key == exported.certs)
		exported.key.clear();


	if (auto *o = acme())
		exported.original = *o;
	else
	if (auto *o = user_provided())
		exported.original = *o;
	else
	if (auto *o = uploaded())
		exported.original = *o;
	else
	if (auto *o = autogenerated())
		exported.original = *o;

	return exported;
}

void securable_socket::cert_info::remove()
{
	if (!resolved_key_path_.is_absolute() || !resolved_certs_path_.is_absolute())
		return;

	if (std::get_if<user_provided_cert_info>(this)) {
		fz::remove_file(resolved_key_path_);
		fz::remove_file(resolved_certs_path_);
	}
	else
	if (std::get_if<uploaded_cert_info>(this)) {
		fz::remove_file(resolved_key_path_);
		fz::remove_file(resolved_certs_path_);
	}
	else
	if (std::get_if<autogenerated_cert_info>(this)) {
		fz::recursive_remove().remove(resolved_key_path_.parent());
	}
	else
	if (std::get_if<acme_cert_info>(this)) {
		fz::recursive_remove().remove(resolved_key_path_.parent());
	}
}

std::string securable_socket::cert_info::fingerprint(const extra &extra) const
{
	return std::visit(util::overload {
		[](const autogenerated_cert_info &i, const auto &) { return i.fingerprint; },
		[](const acme_cert_info &, const acme_cert_info::extra &e) { return e.fingerprint; },
		[](const user_provided_cert_info &, const user_provided_cert_info::extra &e) { return e.fingerprint; },
		[](const uploaded_cert_info &, const uploaded_cert_info::extra &e) { return e.fingerprint; },
		[](const auto &, const auto &) { return std::string(); }
	}, static_cast<const variant&>(*this), static_cast<const extra::variant>(extra));
}

bool securable_socket::cert_info::resolve_paths(logger_interface *logger)
{
	auto error = [logger](auto &&... args) {
		if (logger)
			logger->log_u(logmsg::error, std::forward<decltype(args)>(args)...);

		return false;
	};

	if (root_path_.str().empty())
		return error(L"resolve_paths: oot path is empty.");

	// Transform the exported type into one of the other, proper types.
	if (auto d = std::get_if<exported_cert_info>(this)) {
		auto certs = std::move(d->certs);
		auto key = std::move(d->key);

		if (certs.empty())
			return error("resolve_path: exported_cert_info: certs field is empty");

		cert_info info;

		if (auto *o = d->acme())
			info = std::move(*o);
		else
		if (auto *o = d->autogenerated())
			info = std::move(*o);
		else {
			auto imported_dir = root_path_ / fzT("imported");

			auto try_to_create = [&imported_dir](const native_string &name) -> native_string {
				std::size_t num_tries = 5;

				while (num_tries--) {
					auto now = datetime::now();
					auto date = now.format(fzT("%Y-%m-%dT%H.%M.%S"), datetime::utc);
					auto file_name = sprintf(fzT("%s-%s.%03dT.pem"), name, date, now.get_milliseconds());

					const auto &path = imported_dir / file_name;
					if (path.open(file::writing, file::current_user_and_admins_only | file::empty))
						return path;

					fz::sleep(fz::duration::from_milliseconds(10));
				}

				return {};
			};


			const auto &certs_path = try_to_create(fzT("certs"));
			if (certs_path.empty())
				return error(L"resolve_path: exported_cert_info: could not create certs file.");

			const auto &key_path = key.empty() ? certs_path : try_to_create(fzT("key"));
			if (key_path.empty()) {
				remove_file(certs_path);
				return error(L"resolve_path: exported_cert_info: could not create key file.");
			}

			if (auto *o = d->uploaded()) {
				uploaded_cert_info u = {
					std::move(key_path),
					std::move(certs_path),
					{}
				};

				u.password = std::move(o->password);

				info = std::move(u);
			}
			else {
				user_provided_cert_info u = {
					std::move(key_path),
					std::move(certs_path),
					{}
				};

				if (auto *o = d->user_provided())
					u.password = std::move(o->password);

				info = std::move(u);
			}
		}

		if (!info.set_root_path(root_path_, logger))
			return false;

		if (
			   util::io::write(info.certs_path().open(fz::file::writing, fz::file::current_user_and_admins_only | fz::file::empty), certs)
			&& (key.empty() || util::io::write(info.key_path().open(fz::file::writing, fz::file::current_user_and_admins_only | fz::file::empty), key))
		) {
			*this = std::move(info);
		}
		else {
			fz::remove_file(info.certs_path());
			fz::remove_file(info.key_path());

			return error(L"resolve_path: exported_cert_info: could not write to certs and/or key file.");

		}

		return true;
	}

	if (auto d = std::get_if<user_provided_cert_info>(this)) {
		resolved_key_path_ = root_path_.resolve(d->key_path);
		resolved_certs_path_ = root_path_.resolve(d->certs_path);
	}
	else
	if (auto d = std::get_if<uploaded_cert_info>(this)) {
		resolved_key_path_ = root_path_.resolve(d->key_path);
		resolved_certs_path_ = root_path_.resolve(d->certs_path);
	}
	else
	if (auto d = std::get_if<autogenerated_cert_info>(this)) {
		auto dir = root_path_ / fz::to_native(fz::replaced_substrings(d->fingerprint, ":", ""));
		resolved_key_path_ = dir / fzT("key.pem");
		resolved_certs_path_ = dir / fzT("cert.pem");
	}
	else
	if (auto d = std::get_if<acme_cert_info>(this)) {
		std::sort(d->hostnames.begin(), d->hostnames.end());
		d->hostnames.erase(std::unique(d->hostnames.begin(), d->hostnames.end()), d->hostnames.end());

		auto hashed_hosts = [&d] {
			fz::hash_accumulator acc(hash_algorithm::md5);

			for (auto &h: d->hostnames)
				acc.update(h);

			return acc.digest();
		}();

		auto hashed_account_id = fz::md5(d->account_id);

		auto encoded_account_id = fz::base32_encode(hashed_account_id, base32_type::locale_safe, false);
		auto encoded_hosts = fz::base32_encode(hashed_hosts, base32_type::locale_safe, false);

		auto dir = root_path_ / fzT("acme") / fz::to_native(encoded_account_id) / fz::to_native(encoded_hosts);

		resolved_key_path_ = dir / fzT("key.pem");
		resolved_certs_path_ = dir / fzT("cert.pem");
	}

	return true;
}

securable_socket::securer::securer(securable_socket &owner,
								   bool make_server, tls_ver min_tls_ver,
								   const securable_socket::cert_info *cert_info,
								   tls_system_trust_store *trust_store,
								   securable_socket *socket_to_get_tls_session_from,
								   std::string_view preamble,
								   std::vector<std::string> alpns,
								   bool alpn_mandatory)
	: owner_(owner)
	, make_server_(make_server)
	, socket_to_get_tls_session_from_(socket_to_get_tls_session_from)
	, preamble_(preamble)
	, alpns_(std::move(alpns))
	, alpn_mandatory_(alpn_mandatory)
{
	owner_.logger_.log_u(logmsg::debug_debug, L"securer(%d) ENTERING state = %d", make_server, owner_.securable_state_);

	if (owner_.tls_layer_ != nullptr) {
		auto s = owner_.tls_layer_->get_state();

		if (s == socket_state::connected) {
			if (socket_to_get_tls_session_from_ && !owner_.tls_layer_->resumed_session()) {
				owner_.securable_state_ = securable_socket_state::session_not_resumed;
			}
			else
			if (alpn_mandatory_ && owner_.tls_layer_->get_alpn().empty()) {
				owner_.securable_state_ = securable_socket_state::wrong_alpn;
			}
			else {
				owner_.securable_state_ = securable_socket_state::secured;
			}
		}
		else
		if (s != socket_state::none && s != socket_state::connecting)
			owner_.securable_state_ = securable_socket_state::invalid_socket_state;
	}
	else
	if (owner_.securable_state_ == securable_socket_state::insecure) {
		if (socket_to_get_tls_session_from && !socket_to_get_tls_session_from->is_secure()) {
			owner_.securable_state_ = securable_socket_state::session_socket_not_secure;
		}
		else {
			owner_.tls_layer_ = new fz::tls_layer(owner_.event_loop_, owner_.event_handler_, owner_.socket_stack_->top(), trust_store, owner_.logger_);
			owner_.tls_layer_->set_min_tls_ver(min_tls_ver);
			owner_.tls_layer_->set_unexpected_eof_cb(owner_.eof_cb_);

			owner_.securable_state_ = securable_socket_state::about_to_secure;

			if (cert_info) {
				owner_.logger_.log_u(logmsg::debug_debug, L"calling tls_layer_->set_certificate_file(\"%s\", \"%s\", \"****\")",
														cert_info->key_path(), cert_info->certs_path());

				if (!owner_.tls_layer_->set_certificate_file(cert_info->key_path(), cert_info->certs_path(), cert_info->password())) {
					owner_.securable_state_ = securable_socket_state::failed_setting_certificate_file;
					delete owner_.tls_layer_;
					owner_.tls_layer_ = nullptr;
					owner_.socket_stack_->set_event_handler(owner_.event_handler_);
				}
			}
		}
	}

	owner_.logger_.log_u(logmsg::debug_debug, L"securer(%d) EXITING state = %d", make_server, owner_.securable_state_);
}

securable_socket::securer::~securer()
{
	owner_.logger_.log_u(logmsg::debug_debug, L"~securer(%d) ENTERING state = %d", make_server_, owner_.securable_state_);

	if (owner_.securable_state_ == securable_socket_state::about_to_secure) {
		owner_.securable_state_ = securable_socket_state::securing;

		owner_.socket_stack_->push(std::unique_ptr<fz::tls_layer>(owner_.tls_layer_));

		auto get_session_parameters = [this] {
			if (socket_to_get_tls_session_from_)
				return socket_to_get_tls_session_from_->tls_layer_->get_session_parameters();
			return std::vector<uint8_t>{};
		};

		auto get_host_name = [this] {
			if (socket_to_get_tls_session_from_)
				return socket_to_get_tls_session_from_->tls_layer_->get_hostname();
			return fz::native_string{};
		};

		bool success = true;

		if (!alpns_.empty()) {
			owner_.logger_.log_u(logmsg::debug_debug, L"calling tls_layer_->set_alpn()");
			success = owner_.tls_layer_->set_alpn(alpns_, make_server_);
		}

		if (success) {
			if (make_server_)
				success = owner_.tls_layer_->server_handshake(get_session_parameters(), preamble_, fz::tls_server_flags::no_auto_ticket);
			else
				success = owner_.tls_layer_->client_handshake(owner_.event_handler_, get_session_parameters(), get_host_name());
		}

		if (!success && owner_.event_handler_)
			owner_.event_handler_->send_event<socket_event>(owner_.tls_layer_, socket_event_flag::connection, EPROTO);
	}

	owner_.logger_.log_u(logmsg::debug_debug, L"~securer(%d) EXITING state = %d", make_server_, owner_.securable_state_);
}

securable_socket::securer securable_socket::make_secure_server(tls_ver min_tls_ver, const cert_info &cert_info, securable_socket *socket_to_get_tls_session_from, std::string_view preamble, std::vector<std::string> alpns, bool alpn_mandatory)
{
	return securer(*this, true, min_tls_ver, &cert_info, nullptr, socket_to_get_tls_session_from, preamble, std::move(alpns), alpn_mandatory);
}

securable_socket::securer securable_socket::make_secure_client(tls_ver min_tls_ver, const cert_info *cert_info, tls_system_trust_store *trust_store, securable_socket *socket_to_get_tls_session_from, std::vector<std::string> alpns, bool alpn_mandatory)
{
	return securer(*this, false, min_tls_ver, cert_info, trust_store, socket_to_get_tls_session_from, {}, std::move(alpns), alpn_mandatory);
}

int securable_socket::new_session_ticket()
{
	if (!tls_layer_) {
		return EINVAL;
	}
	return tls_layer_->new_session_ticket();
}

std::string securable_socket::get_alpn() const
{
	if (get_securable_state() == securable_socket_state::secured)
		return tls_layer_->get_alpn();

	return {};
}

void securable_socket::set_unexpected_eof_cb(std::function<bool ()> cb)
{
	eof_cb_= std::move(cb);
}

bool securable_socket::cert_info::extra::expired() const
{
	return std::visit(util::overload {
		[](const std::monostate &) {
			return false;
		},
		[](const auto &e) {
			return e.expiration_time < datetime::now();
		}
	}, static_cast<const variant&>(*this));
}

}
