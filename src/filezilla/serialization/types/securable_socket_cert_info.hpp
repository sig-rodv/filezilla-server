#ifndef FZ_SERIALIZATION_TYPES_SECURABLE_SOCKET_CERT_INFO_HPP
#define FZ_SERIALIZATION_TYPES_SECURABLE_SOCKET_CERT_INFO_HPP

#include "../../securable_socket.hpp"
#include "../helpers.hpp"
#include "../types/optional.hpp"
#include "../types/acme.hpp"

namespace fz::serialization {

template <typename Archive>
void serialize(Archive &ar, securable_socket::user_provided_cert_info &ci)
{
	ar(
		value_info(nvp(ci.key_path,
				   "keyfile"),
				   "Path to the private key in PEM format."),

		value_info(nvp(ci.certs_path,
				   "certsfile"),
				   "Path to the certificates file in PEM format."),

		value_info(optional_nvp(ci.password,
					 "password"),
					 "Password to decrypt private key. *DO NOT USE FOR NEWLY CREATED CERTIFICATES* *ONLY USE WHEN IMPORTING OLD SERVER CONFIG*")

	);
}

template <typename Archive>
void serialize(Archive &ar, securable_socket::uploaded_cert_info &ci)
{
	ar(
		value_info(nvp(ci.key_path,
				   "keyfile"),
				   "Path to the private key in PEM format."),

		value_info(nvp(ci.certs_path,
				   "certsfile"),
				   "Path to the certificates file in PEM format."),

		value_info(optional_nvp(ci.password,
					 "password"),
					 "Password to decrypt private key. *DO NOT USE FOR NEWLY CREATED CERTIFICATES* *ONLY USE WHEN IMPORTING OLD SERVER CONFIG*")

	);
}

template <typename Archive>
void serialize(Archive &ar, securable_socket::autogenerated_cert_info &ci)
{
	ar(
		value_info(nvp(ci.fingerprint,
				   "fingerprint"),
				   "Fingerprint of the autogenerated and selfsigned certificate.")
	);
}

template <typename Archive>
void serialize(Archive &ar, securable_socket::acme_cert_info &ci)
{
	ar(
		value_info(nvp(ci.account_id,
				   "account_id"),
				   "Kid of the ACME account associated with the certificate"),
		value_info(nvp(ci.hostnames,
				   "", "host"),
				   "Hosts the certificate is valid for.")
	);
}

template <typename Archive>
void serialize(Archive &ar, securable_socket::exported_cert_info &ci)
{
	ar(
		value_info(nvp(ci.original,
				   "original"),
				   "The original certificate being exported"),
		value_info(nvp(ci.key,
				   "key"),
				   "The certs private key, in PEM format. If empty, it is assumed that they key is embedded in the certs."),

		value_info(nvp(ci.certs,
				   "certs"),
				   "The certs chain, in PEM format. If key is empty, it is assumed that certs also contains the key itself.")
	);
}

template <typename Archive>
void serialize(Archive &ar, securable_socket::autogenerated_cert_info::extra &e)
{
	ar(
		nvp(e.distinguished_name, "distinguished_name"),
		nvp(e.hostnames, "hostnames"),
		nvp(e.activation_time, "activation_time"),
		nvp(e.expiration_time, "expiration_time")
	);
}

template <typename Archive>
void serialize(Archive &ar, securable_socket::user_provided_cert_info::extra &e)
{
	ar(
		nvp(e.fingerprint, "fingerprint"),
		nvp(e.distinguished_name, "distinguished_name"),
		nvp(e.hostnames, "hostnames"),
		nvp(e.activation_time, "activation_time"),
		nvp(e.expiration_time, "expiration_time")
	);
}

template <typename Archive>
void serialize(Archive &ar, securable_socket::uploaded_cert_info::extra &e)
{
	ar(
		nvp(e.fingerprint, "fingerprint"),
		nvp(e.distinguished_name, "distinguished_name"),
		nvp(e.hostnames, "hostnames"),
		nvp(e.activation_time, "activation_time"),
		nvp(e.expiration_time, "expiration_time")
	);
}

template <typename Archive>
void serialize(Archive &ar, securable_socket::acme_cert_info::extra &e)
{
	ar(
		nvp(e.fingerprint, "fingerprint"),
		nvp(e.distinguished_name, "distinguished_name"),
		nvp(e.account, "account"),
		nvp(e.activation_time, "activation_time"),
		nvp(e.expiration_time, "expiration_time")
	);
}

template <typename Archive>
void serialize(Archive &ar, securable_socket::info &i)
{
	ar.optional_attribute(i.min_tls_ver, "min_protocol_version")(
		nvp(i.cert, "")
	);

	if constexpr (trait::is_input_v<Archive>) {
		if (i.min_tls_ver < tls_ver::v1_2)
			i.min_tls_ver = tls_ver::v1_2;
	}
}

}

#endif // FZ_SERIALIZATION_TYPES_SECURABLE_SOCKET_CERT_INFO_HPP
